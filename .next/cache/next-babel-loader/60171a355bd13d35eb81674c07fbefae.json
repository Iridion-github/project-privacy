{"ast":null,"code":"var _jsxFileName = \"/home/iridion/Desktop/Repos/Freelancer/project-privacy/utils/text.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport { Popover, OverlayTrigger } from 'react-bootstrap';\nimport stringToHTML from 'html-react-parser'; //Questa funzione mi ha ammazzato\n\nexport const getGlossaryPopover = (textRaw, targetsRaw) => {\n  const text = textRaw;\n  const targets = targetsRaw.map(el => el.name);\n  const textFragmented = [...text];\n  let analyzing = [];\n  let found = [];\n\n  for (let x = 0; x < textFragmented.length; x++) {\n    const regex = RegExp('^[a-zA-Z0-9àèéìòù]*$');\n\n    if (regex.test(textFragmented[x])) {\n      analyzing.push(textFragmented[x]);\n    } else {\n      if (targets.map(el => el.toLowerCase()).includes(analyzing.join('').toLowerCase())) {\n        found.push({\n          start: Number(x - analyzing.length),\n          end: x,\n          value: targetsRaw.find(word => word.name === analyzing.join('').toLowerCase()).name,\n          meaning: targetsRaw.find(word => word.name === analyzing.join('').toLowerCase()).meaning,\n          reference: targetsRaw.find(word => word.name === analyzing.join('').toLowerCase()).reference\n        });\n      }\n\n      analyzing = [];\n    }\n  }\n\n  let result = [];\n  let prevTarget = 0;\n  found.forEach((el, i) => {\n    let formattedStr = textRaw.slice(prevTarget, el.start).trim();\n    result.push(formattedStr, \" \");\n\n    let popover = __jsx(Popover, {\n      id: \"glossary-popover\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 37,\n        columnNumber: 7\n      }\n    }, __jsx(Popover.Title, {\n      as: \"h3\",\n      id: \"glossary-popover-title\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 9\n      }\n    }, el.value), __jsx(Popover.Content, {\n      id: \"glossary-popover-content\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 9\n      }\n    }, el.meaning), __jsx(Popover.Title, {\n      id: \"glossary-popover-footer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 42,\n        columnNumber: 9\n      }\n    }, el.reference));\n\n    let segment = __jsx(OverlayTrigger, {\n      trigger: [\"click\", \"hover\", \"focus\"],\n      placement: \"auto\",\n      overlay: popover,\n      key: i,\n      id: \"glossary-word-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 46,\n        columnNumber: 7\n      }\n    }, __jsx(\"span\", {\n      id: \"glossary-word\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 47,\n        columnNumber: 9\n      }\n    }, textRaw.slice(el.start, el.end)));\n\n    result.push(segment, \" \");\n    prevTarget = el.end;\n\n    if (found.length === i + 1 && textRaw.slice(prevTarget).trim().length > 0) {\n      //Se abbiamo markato già tutte le keywords e c'è ancora del testo da stampare.\n      let formattedStr = textRaw.slice(prevTarget).trim();\n      result.push(formattedStr, \" \");\n    }\n  });\n  if (found.length === 0) result = stringToHTML(textRaw.trim());\n  let finalResult = [];\n\n  for (let x = 0; x < result.length; x++) {\n    if (typeof result[x] === \"string\") {\n      //Caso della stringa contenente html\n      finalResult.push(stringToHTML(result[x]));\n    } else {\n      //Caso del component\n      finalResult.push(result[x]);\n    }\n  }\n\n  return finalResult;\n};","map":{"version":3,"sources":["/home/iridion/Desktop/Repos/Freelancer/project-privacy/utils/text.js"],"names":["Popover","OverlayTrigger","stringToHTML","getGlossaryPopover","textRaw","targetsRaw","text","targets","map","el","name","textFragmented","analyzing","found","x","length","regex","RegExp","test","push","toLowerCase","includes","join","start","Number","end","value","find","word","meaning","reference","result","prevTarget","forEach","i","formattedStr","slice","trim","popover","segment","finalResult"],"mappings":"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","sourcesContent":["import {\n  Popover,\n  OverlayTrigger\n} from 'react-bootstrap'\nimport stringToHTML from 'html-react-parser'\n\n//Questa funzione mi ha ammazzato\nexport const getGlossaryPopover = (textRaw, targetsRaw) => {\n  const text = textRaw\n  const targets = targetsRaw.map(el => el.name)\n  const textFragmented = [...text]\n  let analyzing = []\n  let found = []\n  for (let x = 0; x < textFragmented.length; x++) {\n    const regex = RegExp('^[a-zA-Z0-9àèéìòù]*$')\n    if (regex.test(textFragmented[x])) {\n      analyzing.push(textFragmented[x])\n    } else {\n      if (targets.map(el => el.toLowerCase()).includes(analyzing.join('').toLowerCase())) {\n        found.push({\n          start: Number(x - analyzing.length),\n          end: x,\n          value: targetsRaw.find(word => word.name === analyzing.join('').toLowerCase()).name,\n          meaning: targetsRaw.find(word => word.name === analyzing.join('').toLowerCase()).meaning,\n          reference: targetsRaw.find(word => word.name === analyzing.join('').toLowerCase()).reference\n        })\n      }\n      analyzing = []\n    }\n  }\n  let result = []\n  let prevTarget = 0\n  found.forEach((el, i) => {\n    let formattedStr = textRaw.slice(prevTarget, el.start).trim()\n    result.push(formattedStr, \" \")\n    let popover = (\n      <Popover id=\"glossary-popover\">\n        <Popover.Title as=\"h3\" id=\"glossary-popover-title\">{el.value}</Popover.Title>\n        <Popover.Content id=\"glossary-popover-content\">\n          {el.meaning}\n        </Popover.Content>\n        <Popover.Title id=\"glossary-popover-footer\">{el.reference}</Popover.Title>\n      </Popover>\n    )\n    let segment = (\n      <OverlayTrigger trigger={[\"click\", \"hover\", \"focus\"]} placement=\"auto\" overlay={popover} key={i} id=\"glossary-word-container\">\n        <span id=\"glossary-word\">{textRaw.slice(el.start, el.end)}</span>\n      </OverlayTrigger>\n    )\n    result.push(segment, \" \")\n    prevTarget = el.end\n    if (found.length === i + 1 && textRaw.slice(prevTarget).trim().length > 0) { //Se abbiamo markato già tutte le keywords e c'è ancora del testo da stampare.\n      let formattedStr = textRaw.slice(prevTarget).trim()\n      result.push(formattedStr, \" \")\n    }\n  })\n  if (found.length === 0) result = stringToHTML(textRaw.trim())\n  let finalResult = []\n  for (let x = 0; x < result.length; x++) {\n    if (typeof result[x] === \"string\") { //Caso della stringa contenente html\n      finalResult.push(stringToHTML(result[x]))\n    } else { //Caso del component\n      finalResult.push(result[x])\n    }\n  }\n  return finalResult\n}"]},"metadata":{},"sourceType":"module"}